<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebAR Floating Ball + Capture</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    #ui { position: fixed; inset: 0; pointer-events: none; display: flex; align-items: flex-end; justify-content: center;
      background: linear-gradient(to top, rgba(0,0,0,0.35), rgba(0,0,0,0)); padding: 24px; gap: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Apple SD Gothic Neo, sans-serif; color: #fff; }
    .pill { pointer-events: auto; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.25);
      border-radius: 999px; padding: 10px 14px; font-size: 14px; backdrop-filter: blur(6px); display: inline-flex; align-items: center; gap: 8px; }
    .hint { opacity: 0.9; }
    #startOverlay { position: fixed; inset: 0; display: grid; place-items: center; background: #0b1220; color: #e6f1ff; }
    #startOverlay button { all: unset; cursor: pointer; background: #5bc0be; color: #0b1220; padding: 14px 18px; border-radius: 12px; font-weight: 700; box-shadow: 0 8px 22px rgba(0,0,0,0.35); }
    #fallback { position: fixed; inset: 0; display: none; place-items: center; text-align: center; padding: 24px; background:#0b1220; color:#e6f1ff; }
    #fallback a { color: #5bc0be; }
    #flash { position: fixed; inset: 0; background: white; opacity: 0; pointer-events: none; transition: opacity .28s ease; }
    #toast { position: fixed; left: 50%; bottom: 20px; transform: translateX(-50%); background: rgba(0,0,0,.7); color: #fff; padding: 10px 14px; border-radius: 10px; font-size: 13px; opacity: 0; transition: opacity .25s ease, transform .25s ease; pointer-events: none; }
    #toast.show { opacity: 1; transform: translateX(-50%) translateY(-6px); }
  </style>
  <!-- OrbitControls for fallback 3D mode -->
  <script type="module" src="https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"></script>
</head>
<body>
  <div id="startOverlay">
    <div style="text-align:center; max-width: 520px; padding: 24px;">
      <h1 style="margin:0 0 8px;">WebAR 공 띄우기</h1>
      <p style="margin:0 0 18px; opacity:.85">휴대폰에서 실행하고 “AR 시작”을 누른 뒤, 바닥을 향해 기기를 천천히 움직여주세요. 화면을 탭하면 공이 생성됩니다.</p>
      <button id="startBtn">AR 시작</button>
    </div>
  </div>
  <div id="fallback"></div>
  <div id="fallbackUi" style="display:none; position:fixed; inset:0; pointer-events:none; display:flex; align-items:flex-end; justify-content:center; gap:12px; padding:24px;">
    <div class="pill" style="pointer-events:auto;">AR 미지원 기기입니다. 대신 <b>3D 모드</b>로 체험하세요.</div>
    <button id="fallbackStart" class="pill" style="pointer-events:auto;">3D 모드 시작</button>
  </div>
  <div id="ui" aria-hidden="true">
    <div class="pill hint">바닥 인식 후 <strong>탭</strong>으로 공 놓기 • 공은 살짝 둥둥 떠다녀요</div>
    <button id="snapBtn" class="pill" aria-label="사진 찍기" title="사진 찍기" style="pointer-events:auto;">
      📷 사진 찍기
    </button>
    <button id="saveBtn" class="pill" aria-label="앨범에 저장" title="앨범에 저장" style="pointer-events:auto;">
      💾 앨범에 저장
    </button>
  </div>
  <div id="flash"></div>
  <div id="toast"></div>

  <script type="module">
    // Import Three.js (module) and ARButton from CDN
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');
    const fallback = document.getElementById('fallback');
    const fallbackUi = document.getElementById('fallbackUi');
    const fallbackStart = document.getElementById('fallbackStart');
    const ui = document.getElementById('ui');
    const snapBtn = document.getElementById('snapBtn');
    const saveBtn = document.getElementById('saveBtn');
    const flash = document.getElementById('flash');
    const toast = document.getElementById('toast');

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      setTimeout(()=> toast.classList.remove('show'), 1800);
    }

    // Quick feature check
    const canXR = navigator.xr && await navigator.xr.isSessionSupported?.('immersive-ar').catch(()=>false);
    if (!canXR) {
      startOverlay.style.display = 'none';
      fallback.style.display = 'grid';
      fallback.innerHTML = `<div><h2>이 기기는 WebXR AR을 지원하지 않아요</h2>
        <p>Chrome(안드로이드, ARCore), 또는 iOS Safari(지원 기기)에서 HTTPS로 열어주세요.</p>
        <p>아래 <b>3D 모드</b>로도 체험할 수 있어요.</p></div>`;
      fallbackUi.style.display = 'flex';
    }

    // Three.js basics (enable preserveDrawingBuffer for screenshots)
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // Reticle (placement guide)
    const reticleGeo = new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2);
    const reticleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.85, transparent: true });
    const reticle = new THREE.Mesh(reticleGeo, reticleMat);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Ball (created on tap)
    const balls = [];
    function createFloatingBall(pos){
      const geo = new THREE.SphereGeometry(0.12, 48, 48);
      const mat = new THREE.MeshStandardMaterial({ metalness: 0.1, roughness: 0.3, envMapIntensity: 1.0, color: 0x66a6ff });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(pos);
      mesh.userData.baseY = pos.y + 0.12; // hover baseline
      mesh.userData.phase = Math.random() * Math.PI * 2;
      scene.add(mesh);
      balls.push(mesh);
      return mesh;
    }

    // XR variables
    let xrRefSpace = null;
    let hitTestSource = null;

    async function onSessionStart(){
      const session = renderer.xr.getSession();

      // DOM overlay so we can still show hints
      try { await session.updateRenderState({ domOverlay: { root: document.body } }); } catch(e){}

      xrRefSpace = await session.requestReferenceSpace('local');
      const viewerSpace = await session.requestReferenceSpace('viewer');
      hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

      // Tap to place a ball at reticle
      renderer.domElement.addEventListener('click', () => {
        if (!reticle.visible) return;
        const mat = new THREE.Matrix4();
        mat.fromArray(reticle.matrix.elements);
        const pos = new THREE.Vector3().setFromMatrixPosition(mat);
        createFloatingBall(pos);
      });

      // Handle resize
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      startOverlay.style.display = 'none';
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame){
      // Hit test (reticle)
      if (frame && hitTestSource && xrRefSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length > 0) {
          const hit = hits[0];
          const pose = hit.getPose(xrRefSpace);
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      }

      // Float animation
      const t = (timestamp || 0) * 0.001;
      for (const b of balls) {
        const amp = 0.03; // 3cm bobbing
        b.position.y = b.userData.baseY + Math.sin(t * 2 + b.userData.phase) * amp;
        b.rotation.y += 0.01;
      }

      renderer.render(scene, camera);
    }

    // ---- Capture & Save ----
    let lastBlob = null; // keep last captured image

    async function capturePNGBlob(){
      // Flash effect
      flash.style.opacity = 0.8;
      setTimeout(()=> flash.style.opacity = 0, 60);

      // Temporarily hide UI for clean capture
      ui.style.opacity = 0; ui.style.pointerEvents = 'none';
      // Render one more frame to ensure UI hidden
      renderer.render(scene, camera);

      const canvas = renderer.domElement;
      const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));

      ui.style.opacity = 1; ui.style.pointerEvents = '';

      if (!blob) throw new Error('이미지 캡처 실패');
      lastBlob = blob;
      showToast('사진이 캡처되었습니다');
      return blob;
    }

    async function saveToAlbum(){
      try {
        const blob = lastBlob || await capturePNGBlob();
        const file = new File([blob], `webar_${Date.now()}.png`, { type: 'image/png' });

        // Prefer Web Share Target (mobile share sheet → 사진 보관함 저장 가능)
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
          await navigator.share({ files: [file], title: 'WebAR Capture', text: 'WebAR에서 캡처한 이미지' });
          showToast('공유 시트가 열렸습니다');
          return;
        }

        // Fallback: trigger download (Android Chrome/데스크탑에서 파일로 저장)
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = file.name; a.click();
        URL.revokeObjectURL(url);
        showToast('이미지 파일이 저장(다운로드)되었습니다');
      } catch (e) {
        console.error(e);
        showToast('저장에 실패했습니다');
      }
    }

    snapBtn.addEventListener('click', async ()=>{
      try { await capturePNGBlob(); } catch(e){ console.error(e); showToast('캡처 실패'); }
    });

    saveBtn.addEventListener('click', async ()=>{ await saveToAlbum(); });

    // iOS Safari tip: long-press on image opened in a new tab to Save Image
    // (Not used by default, but left as util)
    async function openInNewTab(){
      const blob = lastBlob || await capturePNGBlob();
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
      setTimeout(()=> URL.revokeObjectURL(url), 10000);
    }

    // ---- Start AR ----
    startBtn?.addEventListener('click', async () => {
      try {
        const session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });
        renderer.xr.setSession(session);
        onSessionStart();
      } catch (e) {
        console.error(e);
        startOverlay.style.display = 'none';
        fallback.style.display = 'grid';
        fallback.innerHTML = `<div><h2>AR 세션을 시작할 수 없어요</h2><p>${String(e)}</p><p><b>3D 모드</b>로 계속할 수 있어요.</p></div>`;
        fallbackUi.style.display = 'flex';
      }
    });

    // ======= Fallback 3D mode (no AR) =======
    let isFallback3D = false;
    async function startFallback3D(){
      isFallback3D = true;
      startOverlay.style.display = 'none';
      fallback.style.display = 'none';
      fallbackUi.style.display = 'none';

      // Reset renderer for non-XR
      renderer.xr.enabled = false;
      renderer.setAnimationLoop(null);

      // Simple ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(8, 8),
        new THREE.MeshStandardMaterial({ color: 0x1f2636, metalness:0.0, roughness:0.9 })
      );
      ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

      // Camera position & controls
      camera.position.set(0, 1.2, 2.5);
      const { OrbitControls } = await import('https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js');
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0.6, 0); controls.update();

      // Click to spawn on ground (raycast)
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      function onClick(e){
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hit = raycaster.intersectObject(ground)[0];
        if (hit){
          const p = hit.point.clone(); p.y += 0.12;
          createFloatingBall(p);
        }
      }
      renderer.domElement.addEventListener('click', onClick);

      // Animate
      function loop(time){
        const t = (time||0)*0.001;
        for (const b of balls){
          const amp = 0.03; b.position.y = b.userData.baseY + Math.sin(t*2 + b.userData.phase)*amp; b.rotation.y += 0.01;
        }
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    }
    fallbackStart?.addEventListener('click', startFallback3D);
  </script>
</body>
</html>
</body>
</html>
